From 176325bbe30e6ec11c1b0ddae9f843921c9dc373 Mon Sep 17 00:00:00 2001
From: "Zhao, Xinda" <xinda.zhao@intel.com>
Date: Wed, 10 May 2017 09:22:50 +0800
Subject: [PATCH] POC: Add GPU cgroup support

GPU memory and priority support in cgroup is added.

Signed-off-by: Zhao, Xinda <xinda.zhao@intel.com>
---
 .../opencontainers/runtime-spec/specs-go/config.go | 10 +++
 libcontainer/cgroups/fs/apply_raw.go               |  1 +
 libcontainer/cgroups/fs/gpu.go                     | 74 ++++++++++++++++++++++
 libcontainer/configs/cgroup_unix.go                |  6 ++
 libcontainer/specconv/spec_linux.go                |  8 +++
 update.go                                          | 23 +++++++
 6 files changed, 122 insertions(+)
 create mode 100644 libcontainer/cgroups/fs/gpu.go

diff --git a/Godeps/_workspace/src/github.com/opencontainers/runtime-spec/specs-go/config.go b/Godeps/_workspace/src/github.com/opencontainers/runtime-spec/specs-go/config.go
index 491b734..f94a892 100644
--- a/Godeps/_workspace/src/github.com/opencontainers/runtime-spec/specs-go/config.go
+++ b/Godeps/_workspace/src/github.com/opencontainers/runtime-spec/specs-go/config.go
@@ -311,6 +311,14 @@ type Network struct {
 	Priorities []InterfacePriority `json:"priorities,omitempty"`
 }
 
+// GPU for Linux cgroup 'gpu' resource management
+type GPU struct {
+	// GPU Mem Limit
+	Memory *uint64 `json:"memory,omitempty"`
+	// GPU Priority
+	Priority *int64 `json:"prio,omitempty"`
+}
+
 // Resources has container runtime resource constraints
 type Resources struct {
 	// Devices configures the device whitelist.
@@ -331,6 +339,8 @@ type Resources struct {
 	HugepageLimits []HugepageLimit `json:"hugepageLimits,omitempty"`
 	// Network restriction configuration
 	Network *Network `json:"network,omitempty"`
+	// GPU resource restriction configuration
+	GPU *GPU `json:"gpu,omitempty"`
 }
 
 // Device represents the mknod information for a Linux special device file
diff --git a/libcontainer/cgroups/fs/apply_raw.go b/libcontainer/cgroups/fs/apply_raw.go
index 30b2063..3ecb0f6 100644
--- a/libcontainer/cgroups/fs/apply_raw.go
+++ b/libcontainer/cgroups/fs/apply_raw.go
@@ -31,6 +31,7 @@ var (
 		&PerfEventGroup{},
 		&FreezerGroup{},
 		&NameGroup{GroupName: "name=systemd", Join: true},
+		&GPUGroup{},
 	}
 	HugePageSizes, _ = cgroups.GetHugePageSize()
 )
diff --git a/libcontainer/cgroups/fs/gpu.go b/libcontainer/cgroups/fs/gpu.go
new file mode 100644
index 0000000..0706017
--- /dev/null
+++ b/libcontainer/cgroups/fs/gpu.go
@@ -0,0 +1,74 @@
+// +build linux
+
+package fs
+
+import (
+        "fmt"
+        "os"
+        "strconv"
+
+        "github.com/opencontainers/runc/libcontainer/cgroups"
+        "github.com/opencontainers/runc/libcontainer/configs"
+)
+
+const (
+        cgroupGPUMemoryLimit = "gpu.max_mem_in_bytes"
+        cgroupGPUPriority    = "gpu.priority"
+)
+
+type GPUGroup struct {
+}
+
+func (s *GPUGroup) Name() string {
+        return "gpu"
+}
+
+func (s *GPUGroup) Apply(d *cgroupData) (err error) {
+        path, err := d.path("gpu")
+        if err != nil && !cgroups.IsNotFound(err) {
+                return err
+        } else if path == "" {
+                return nil
+        }
+        fmt.Printf("gpu cgroup %s %d\n", path, d.pid)
+
+        if err := os.MkdirAll(path, 0755); err != nil {
+                return err
+        }
+
+        if err := cgroups.WriteCgroupProc(path, d.pid); err != nil {
+                return err
+        }
+
+        return nil
+}
+
+func (s *GPUGroup) Set(path string, cgroup *configs.Cgroup) error {
+
+        if cgroup.Resources.GpuMemory != 0 {
+                if err := writeFile(path, cgroupGPUMemoryLimit, strconv.FormatUint(cgroup.Resources.GpuMemory, 10)); err != nil {
+                        return err
+                }
+        }
+
+        if cgroup.Resources.GpuPriority != 0 {
+                if err := writeFile(path, cgroupGPUPriority, strconv.FormatInt(cgroup.Resources.GpuPriority, 10)); err != nil {
+                        return err
+                }
+        }
+
+        return nil
+}
+
+func (s *GPUGroup) Remove(d *cgroupData) error {
+        return removePath(d.path("gpu"))
+}
+
+func (s *GPUGroup) GetStats(path string, stats *cgroups.Stats) error {
+        return nil
+}
+
+func gpuAssigned(cgroup *configs.Cgroup) bool {
+        return cgroup.Resources.GpuMemory != 0 ||
+                cgroup.Resources.GpuPriority != 0
+}
diff --git a/libcontainer/configs/cgroup_unix.go b/libcontainer/configs/cgroup_unix.go
index 14d6289..96bdd85 100644
--- a/libcontainer/configs/cgroup_unix.go
+++ b/libcontainer/configs/cgroup_unix.go
@@ -121,4 +121,10 @@ type Resources struct {
 
 	// Set class identifier for container's network packets
 	NetClsClassid uint32 `json:"net_cls_classid_u"`
+
+	// GPU Memory limit (in bytes)
+	GpuMemory uint64 `json:"gpu_memory"`
+
+	// GPU priority
+	GpuPriority int64 `json:"gpu_prio"`
 }
diff --git a/libcontainer/specconv/spec_linux.go b/libcontainer/specconv/spec_linux.go
index fec1978..11e2fb7 100644
--- a/libcontainer/specconv/spec_linux.go
+++ b/libcontainer/specconv/spec_linux.go
@@ -464,6 +464,14 @@ func createCgroupConfig(name string, useSystemdCgroup bool, spec *specs.Spec) (*
 			})
 		}
 	}
+	if r.GPU != nil {
+		if r.GPU.Memory != nil {
+			c.Resources.GpuMemory = *r.GPU.Memory
+		}
+		if r.GPU.Priority != nil {
+			c.Resources.GpuPriority = *r.GPU.Priority
+		}
+	}
 	return c, nil
 }
 
diff --git a/update.go b/update.go
index 87dc83c..ef1c943 100644
--- a/update.go
+++ b/update.go
@@ -13,6 +13,7 @@ import (
 	"github.com/urfave/cli"
 )
 
+func i64Ptr(i int64) *int64   { return &i }
 func u64Ptr(i uint64) *uint64 { return &i }
 func u16Ptr(i uint16) *uint16 { return &i }
 
@@ -134,6 +135,10 @@ other options are ignored.
 			BlockIO: &specs.BlockIO{
 				Weight: u16Ptr(0),
 			},
+			GPU: &specs.GPU{
+				Memory:   u64Ptr(0),
+				Priority: i64Ptr(0),
+			},
 		}
 
 		config := container.Config()
@@ -188,6 +193,20 @@ other options are ignored.
 			}
 			for _, pair := range []struct {
 				opt  string
+				dest *int64
+			}{
+				{"gpu_prio", r.GPU.Priority},
+			} {
+				if val := context.String(pair.opt); val != "" {
+					var err error
+					*pair.dest, err = strconv.ParseInt(val, 10, 64)
+					if err != nil {
+						return fmt.Errorf("invalid value for %s: %s", pair.opt, err)
+					}
+				}
+			}
+			for _, pair := range []struct {
+				opt  string
 				dest *uint64
 			}{
 				{"kernel-memory", r.Memory.Kernel},
@@ -195,6 +214,7 @@ other options are ignored.
 				{"memory", r.Memory.Limit},
 				{"memory-reservation", r.Memory.Reservation},
 				{"memory-swap", r.Memory.Swap},
+				{"gpu_memory", r.GPU.Memory},
 			} {
 				if val := context.String(pair.opt); val != "" {
 					v, err := units.RAMInBytes(val)
@@ -221,6 +241,9 @@ other options are ignored.
 		config.Cgroups.Resources.MemoryReservation = int64(*r.Memory.Reservation)
 		config.Cgroups.Resources.MemorySwap = int64(*r.Memory.Swap)
 
+		config.Cgroups.Resources.GpuMemory = *r.GPU.Memory
+		config.Cgroups.Resources.GpuPriority = *r.GPU.Priority
+
 		if err := container.Set(config); err != nil {
 			return err
 		}
-- 
2.7.4

